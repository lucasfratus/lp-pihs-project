#[cfg(feature = "buddy-alloc")]
mod alloc;
mod wasm4;
use wasm4::*;

// Global and Objects ------------------------------------------------------------------------------------------------------
// Game State and Settings
static mut GAME_MENU: bool = true;
static mut GAME_OVER: bool = false;
static mut FRAME_COUNT: u32 = 0;
static mut RNG_SEED: u32 = 123456789;

// Scenario Settings
const FLOOR_HEIGHT: i32 = 148;
const GRAVITY: i32 = 1;
static mut SCENARIO_SPEED: i32 = 1;

// Player Settings
const PLAYER_SIZE: i32 = 8;
const PLAYER_JUMP_FORCE: i32 = -14;

// Coins Settings
const COIN_SIZE: i32 = 10;
const COIN_MAX_Y: i32 = 60;
const COIN_MIN_Y: i32 = 135;
static mut COIN_SPEED: i32 = 2;

// Barrier Settings
const BARRIER_WIDTH: i32 = 12;
const BARRIER_GAP: i32 = 50;
const BARRIER_DISPLACEMENT: i32 = 10;
const BARRIER_UP_HEIGHT: i32 = 90;
const BARRIER_DOWN_HEIGHT: i32 = 80;

// Fireball Settings
const BALL_SIZE: i32 = 10;
const BALL_X_SPEED: i32 = 2;
const BALL_Y_SPEED: i32 = 1;

// Player Struct
pub(crate) struct Player {
    x: i32,
    y: i32,
    velocity_y: i32,
    is_jumping: bool,
    score: u8,
    lives: u8,
}

// Coin Struct
struct Coin {
    x: i32,
    y: i32,
    not_collected: bool,
}

// Barrier Struct
struct Barrier {
    x: i32,
    y: i32,
    height: i32,
    active: bool,
}

// Fireball Struct
struct Ball {
    x: i32,
    y: i32,
    active: bool,
    rising: bool,
}

// Build Global Structs ----------------------------------------------------------------------------------------------------
static mut PLAYER: Player = Player { 
    x: 45,
    y: 30,
    velocity_y: 0,
    is_jumping: true,
    score: 0,
    lives: 3
};

static mut COIN: Coin = Coin {
    x: SCREEN_SIZE as i32 + 20,
    y: 100,
    not_collected: true,
};

static mut BARRIERS: [Barrier; 2] = [
    Barrier {
        x: SCREEN_SIZE as i32 + BARRIER_WIDTH,
        y: BARRIER_DOWN_HEIGHT,
        height: FLOOR_HEIGHT - BARRIER_DOWN_HEIGHT,
        active: true,
    },
    Barrier {
        x: SCREEN_SIZE as i32 + BARRIER_WIDTH + BARRIER_GAP,
        y: 0,
        height: BARRIER_UP_HEIGHT,
        active: true,
    }
];

static mut BALL: Ball = Ball {
    x: SCREEN_SIZE as i32 + BALL_SIZE,
    y: 0,
    active: true,
    rising: false,
};

// Game Start Functions ----------------------------------------------------------------------------------------------------
fn check_game_start() {
    unsafe {
        let gamepad = *wasm4::GAMEPAD1;
        if gamepad & BUTTON_1 != 0 {
            GAME_MENU = false;
            start();
        }
    }
}

#[no_mangle]
pub fn start() {
    unsafe {
        *PALETTE = [
            0x130026,
            0x7451c8,
            0xff66b2,
            0xf2ccff,
        ];

        // Game State Settings
        SCENARIO_SPEED = 1;
        FRAME_COUNT = 0;
        GAME_OVER = false;
        
        // Player
        PLAYER.x = 45;
        PLAYER.y = 30;
        PLAYER.velocity_y = 0;
        PLAYER.is_jumping = true;
        PLAYER.score = 0;
        PLAYER.lives = 3;

        // Coin
        COIN.x = SCREEN_SIZE as i32 + 20;
        COIN.y = random_range(COIN_MAX_Y, COIN_MIN_Y);
        COIN.not_collected = true;

        // Barriers
        BARRIERS[0].x = SCREEN_SIZE as i32 + BARRIER_WIDTH;
        BARRIERS[0].y = BARRIER_DOWN_HEIGHT;
        BARRIERS[0].height = FLOOR_HEIGHT - BARRIER_DOWN_HEIGHT;
        BARRIERS[0].active = true;
        BARRIERS[1].x = SCREEN_SIZE as i32 + BARRIER_WIDTH + BARRIER_GAP;
        BARRIERS[1].y = 0;
        BARRIERS[1].height = BARRIER_UP_HEIGHT;
        BARRIERS[1].active = true;

        // Ball
        BALL.x = SCREEN_SIZE as i32 + BALL_SIZE;
        BALL.y = random_range(0, FLOOR_HEIGHT);
        if BALL.y < FLOOR_HEIGHT / 2 {
            BALL.rising = false
        } else {
            BALL.rising = true
        }
        BALL.active = true;
    }
}

// Logical Functions -------------------------------------------------------------------------------------------------------
fn random_u32() -> u32 {
    unsafe {
        RNG_SEED = RNG_SEED.wrapping_mul(1664525).wrapping_add(1013904223);
        RNG_SEED
    }
}

fn random_range(min: i32, max: i32) -> i32 {
    let r = random_u32();
    min + (r % ((max - min + 1) as u32)) as i32
}

fn collision(a_x: i32, a_y: i32, a_w: i32, a_h: i32, b_x: i32, b_y: i32, b_w: i32, b_h: i32) -> bool {
    a_x < b_x + b_w &&
    a_x + a_w > b_x &&
    a_y < b_y + b_h &&
    a_y + a_h > b_y
}

// Game Update Functions ---------------------------------------------------------------------------------------------------
fn update_player_position() {
    unsafe {
        let gamepad = *wasm4::GAMEPAD1;
        // Horizontal Movement
        if gamepad & BUTTON_LEFT != 0 {
            PLAYER.x -= 2;
        }
        if gamepad & BUTTON_RIGHT != 0 {
            PLAYER.x += 2;
        }

        // Jump Movement
        if gamepad & BUTTON_1 != 0 && !PLAYER.is_jumping {
            PLAYER.velocity_y = PLAYER_JUMP_FORCE;
            PLAYER.is_jumping = true;
        }

        // Apply Gravity
        PLAYER.velocity_y += GRAVITY;
        PLAYER.y += PLAYER.velocity_y;
        
        // Checks if Player has reached the floor
        if PLAYER.y >= FLOOR_HEIGHT {
            PLAYER.y = FLOOR_HEIGHT;
            PLAYER.velocity_y = 0;
            PLAYER.is_jumping = false;
        }

        // Limit the Player on the screen
        if PLAYER.x < 0 {
            PLAYER.x = 0;
        }
        if PLAYER.y < 0 {
            PLAYER.y = 0;
        }
        if PLAYER.x > SCREEN_SIZE as i32 - PLAYER_SIZE {
            PLAYER.x = SCREEN_SIZE as i32 - PLAYER_SIZE;
        }
        if PLAYER.y > FLOOR_HEIGHT - PLAYER_SIZE {
            PLAYER.y = FLOOR_HEIGHT - PLAYER_SIZE;
        }
    }
}

fn check_player_death() {
    unsafe {
        if PLAYER.lives == 0 {
                GAME_OVER = true;
        }
    }
}

fn update_player() {
    update_player_position();
    check_player_death();
}

fn update_coin() {
    unsafe {
        COIN.x -= COIN_SPEED;
        if COIN.x + COIN_SIZE < 0 {
            COIN.x = SCREEN_SIZE as i32 + 20;
            COIN.not_collected = true;
            COIN.y = random_range(COIN_MAX_Y, COIN_MIN_Y);
        }
    }
}

fn update_barriers() {
    unsafe {
        BARRIERS[0].x -= SCENARIO_SPEED;
        BARRIERS[1].x -= SCENARIO_SPEED;

        if BARRIERS[0].x + BARRIER_WIDTH < 0 {
            BARRIERS[0].x = SCREEN_SIZE as i32 + 20 + random_range(-BARRIER_DISPLACEMENT, BARRIER_DISPLACEMENT);
            BARRIERS[0].active = true;
            BARRIERS[0].y = BARRIER_DOWN_HEIGHT + random_range(-BARRIER_DISPLACEMENT, BARRIER_DISPLACEMENT);
            BARRIERS[0].height = FLOOR_HEIGHT - BARRIERS[0].y;
        }
        if BARRIERS[1].x + BARRIER_WIDTH < 0 {
            BARRIERS[1].x = BARRIERS[0].x + BARRIER_GAP + random_range(-BARRIER_DISPLACEMENT, BARRIER_DISPLACEMENT);
            BARRIERS[1].active = true;
            BARRIERS[1].height = BARRIER_UP_HEIGHT + random_range(-BARRIER_DISPLACEMENT, BARRIER_DISPLACEMENT);
        }
    }
}

fn update_ball() {
    unsafe {
        BALL.x -= BALL_X_SPEED;
        if BALL.y <= SCREEN_SIZE as i32 {
            if BALL.rising {
                BALL.y -= BALL_Y_SPEED
            } else {
                BALL.y += BALL_Y_SPEED
            }
        }

        if BALL.x + BALL_SIZE < 0 {
            BALL.x = SCREEN_SIZE as i32 + BALL_SIZE + 30;
            BALL.y = random_range(0, FLOOR_HEIGHT);
            if BALL.y < FLOOR_HEIGHT / 2 {
                BALL.rising = false
            } else {
                BALL.rising = true
            }
            BALL.active = true;
        }
    }
}

fn player_coin_interaction() {
    unsafe {
        if COIN.not_collected && collision(PLAYER.x, PLAYER.y, PLAYER_SIZE, PLAYER_SIZE, COIN.x, COIN.y, COIN_SIZE, COIN_SIZE){
            COIN.not_collected = false;
            PLAYER.score += 1;
        }
    }
}

fn player_barrier_interaction() {
    unsafe {
        if BARRIERS[0].active && collision(PLAYER.x, PLAYER.y, PLAYER_SIZE, PLAYER_SIZE, BARRIERS[0].x, BARRIERS[0].y, BARRIER_WIDTH, BARRIERS[0].height) {
            PLAYER.lives = PLAYER.lives.saturating_sub(1);
            BARRIERS[0].active = false;
        }
        if BARRIERS[1].active && collision(PLAYER.x, PLAYER.y, PLAYER_SIZE, PLAYER_SIZE, BARRIERS[1].x, BARRIERS[1].y, BARRIER_WIDTH, BARRIERS[1].height) {
            PLAYER.lives = PLAYER.lives.saturating_sub(1);
            BARRIERS[1].active = false;
        }
    }
}

fn player_ball_interaction() {
    unsafe {
        if BALL.active && collision(PLAYER.x, PLAYER.y, PLAYER_SIZE, PLAYER_SIZE, BALL.x, BALL.y, BALL_SIZE, BALL_SIZE) {
            PLAYER.lives = PLAYER.lives.saturating_sub(1);
            BALL.active = false;
        }
    }
}

fn game_active_update() {
    update_player();
    update_coin();
    update_barriers();
    update_ball();
    player_coin_interaction();
    player_barrier_interaction();
    player_ball_interaction();
}

// Draw Functions ----------------------------------------------------------------------------------------------------------
fn draw_sky() {
    // Sky
    unsafe { *DRAW_COLORS = 4 }
    rect(0, 0, 160, FLOOR_HEIGHT as u32);
    
    // Sun
    unsafe { *DRAW_COLORS = 3 }
    oval(10,20, 29, 29);

    // Clouds
    unsafe {
        *DRAW_COLORS = 0x03;
        blit(
            &[ 0xff,0xff,0x0f,0xff,0xff,0xf8,0x07,0xff,0xff,0xe3,0xe7,0xff,0xff,0x9c,0x07,0xff,0xff,0x20,0x0f,0xff,0xfc,0x00,0x0f,0xfe,0x18,0x00,0x1f,0xf0,0x00,0x00,0x3f,0xcc,0x10,0x00,0x7f,0x30,0x30,0x00,0x7e,0xc0,0x20,0x00,0x39,0x00,0x40,0x00,0x32,0x00,0x00,0x38,0x24,0x00,0x00,0xc0,0x48,0x00,0x03,0x00,0x40,0x00,0x04,0x00,0x80,0x00,0x08,0x01,0x80,0x00,0x00,0x03,0x80,0x00,0x00,0x0f,0xc3,0x00,0x00,0x1f,0xff,0x00,0x00,0x7f,0xff,0x86,0x01,0xff,0xff,0xff,0x0f,0x80 ],
            66,
            19,
            31,
            23,
            BLIT_1BPP,
        );
        blit(
            &[ 0xff,0xf8,0x7f,0xff,0xff,0xf8,0x07,0xff,0xff,0xfc,0x30,0xff,0xff,0xfe,0x18,0x1f,0xff,0xff,0x8c,0x00,0x7f,0xff,0xc6,0x00,0x07,0xff,0xf1,0x00,0x00,0xff,0xfc,0x00,0x00,0x0f,0xff,0x00,0x00,0x01,0xfe,0x00,0x00,0x00,0x3e,0x00,0x00,0xe0,0x07,0x00,0x00,0xe0,0x09,0x86,0x00,0x60,0x02,0x23,0x00,0x30,0x00,0x41,0x80,0x08,0x00,0x10,0x40,0x06,0x00,0x00,0x10,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x01,0xc0,0x00,0x00,0x00,0xf8,0x04,0x00,0x00,0x7f,0x87,0x80,0x00,0x7f,0xff,0xf8,0x03,0xff ],
            119,
            32,
            34,
            24,
            BLIT_1BPP,
        );
    }
}

fn draw_floor() {
    /*
    unsafe {
        *DRAW_COLORS = 0x02;
        blit(
            &[ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x1f,0xf0,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x03,0xff,0x00,0x00,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x3f,0xff,0xe0,0x07,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x1f,0xf0,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x07,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff ],
            0,
            FLOOR_HEIGHT,
            SCREEN_SIZE,
            SCREEN_SIZE - FLOOR_HEIGHT as u32,
            BLIT_1BPP,
        );
    }
    */
    unsafe { *DRAW_COLORS = 0 }
    rect(0, FLOOR_HEIGHT, SCREEN_SIZE, SCREEN_SIZE - FLOOR_HEIGHT as u32);
}

fn draw_barriers() {
    unsafe {
        *DRAW_COLORS = 0x4123;
        if BARRIERS[0].active {
            blit(
                &[ 0xc0,0x00,0x03,0x0a,0xaa,0xa0,0x2a,0x00,0xa8,0x0a,0xaa,0xa0,0x40,0x00,0x01,0x55,0x55,0x55,0x55,0x55,0x15,0x51,0x55,0x15,0x51,0x55,0x45,0x51,0x55,0x45,0x54,0x55,0x45,0x54,0x55,0x45,0x54,0x55,0x45,0x55,0x55,0x55,0x55,0x55,0x55,0x51,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x55,0x45,0x55,0x55,0x45,0x55,0x55,0x45,0x45,0x55,0x45,0x45,0x55,0x45,0x45,0x55,0x45,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x51,0x15,0x55,0x51,0x55,0x55,0x51,0x55,0x55,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x45,0x54,0x54,0x45,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x51,0x55,0x51,0x51,0x55,0x51,0x51,0x55,0x15,0x51,0x55,0x15,0x51,0x55,0x15,0x55,0x54,0x55,0x55,0x54,0x55,0x55,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x55,0x55,0x51,0x55,0x55,0x51,0x55,0x55,0x51,0x51,0x55,0x51,0x51,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x54,0x54,0x55,0x54,0x55,0x55,0x54,0x55,0x55,0x54,0x55,0x51,0x54,0x55,0x51,0x55,0x51,0x51,0x45,0x51,0x51,0x45,0x51,0x45,0x45,0x51,0x45,0x45,0x51,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x55,0x55,0x51,0x55,0x55,0x51,0x55,0x15,0x51,0x55,0x15,0x51,0x55,0x45,0x51,0x55,0x45,0x54,0x55,0x45,0x54,0x55,0x45,0x54,0x55,0x45,0x55,0x55,0x55,0x55,0x55,0x55,0x51,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45 ],
                BARRIERS[0].x,
                BARRIERS[0].y,
                BARRIER_WIDTH as u32,
                116,
                BLIT_2BPP,
            );
        }
        if BARRIERS[1].active {
            blit(
                &[ 0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x55,0x55,0x15,0x55,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x51,0x55,0x15,0x55,0x55,0x55,0x55,0x55,0x55,0x54,0x55,0x45,0x54,0x55,0x45,0x54,0x55,0x45,0x51,0x55,0x45,0x51,0x55,0x45,0x51,0x55,0x15,0x51,0x55,0x15,0x51,0x55,0x55,0x51,0x55,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x45,0x51,0x55,0x45,0x51,0x45,0x45,0x51,0x45,0x45,0x51,0x51,0x55,0x51,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x55,0x54,0x55,0x55,0x54,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x51,0x55,0x51,0x51,0x55,0x51,0x55,0x55,0x51,0x55,0x55,0x51,0x55,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x55,0x54,0x55,0x55,0x54,0x55,0x55,0x54,0x55,0x51,0x55,0x15,0x51,0x55,0x15,0x51,0x55,0x15,0x51,0x55,0x51,0x51,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x55,0x51,0x54,0x54,0x45,0x54,0x54,0x45,0x54,0x54,0x55,0x55,0x54,0x55,0x55,0x51,0x55,0x55,0x51,0x55,0x45,0x51,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x45,0x45,0x55,0x45,0x45,0x55,0x45,0x55,0x55,0x45,0x55,0x55,0x45,0x55,0x55,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x15,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x54,0x54,0x55,0x55,0x55,0x15,0x55,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x45,0x55,0x15,0x51,0x55,0x15,0x55,0x55,0x55,0x55,0x55,0x55,0x54,0x55,0x45,0x54,0x55,0x45,0x54,0x55,0x45,0x51,0x55,0x45,0x51,0x55,0x45,0x51,0x55,0x15,0x55,0x55,0x15,0x55,0x55,0x55,0x40,0x00,0x01,0x0a,0xaa,0xa0,0x2a,0x00,0xa8,0x0a,0xaa,0xa0,0xc0,0x00,0x03 ],
                BARRIERS[1].x,
                BARRIERS[1].y,
                BARRIER_WIDTH as u32,
                116,
                BLIT_2BPP,
            );
        }
    }
}

fn draw_coin() {
    unsafe {
        if COIN.not_collected {
            *DRAW_COLORS = 0x0023;
            blit(
                &[ 0xa8,0x02,0xaa,0x05,0x0a,0x81,0x54,0x20,0x15,0x40,0x04,0x51,0x00,0x45,0x10,0x01,0x54,0x08,0x15,0x42,0xa0,0x50,0xaa,0x80,0x2a ],
                COIN.x,
                COIN.y,
                COIN_SIZE as u32,
                COIN_SIZE as u32,
                BLIT_2BPP,
            );
        }
    }
}

fn draw_player() {
    unsafe {
        *DRAW_COLORS = 0x0123;
        blit(
            &[ 0xd5,0x5f,0x55,0x57,0x78,0x8f,0xda,0xaf,0xd5,0xaa,0xd6,0xab,0xda,0xa7,0x59,0x9f ],
            PLAYER.x,
            PLAYER.y,
            PLAYER_SIZE as u32,
            PLAYER_SIZE as u32,
            BLIT_2BPP,
        );
    }
}

fn draw_ball() {
    unsafe {
        *DRAW_COLORS = 2;
        if BALL.active {
            rect(BALL.x, BALL.y, BALL_SIZE as u32, BALL_SIZE as u32)
        }
    }
}

fn draw_hud() {
    unsafe {
        *DRAW_COLORS = 1;
        let coins_qnty = PLAYER.score;
        let coins_text = format!("Coins: {}", coins_qnty);
        text(&coins_text, 10, 10);

        let lives_qnty = PLAYER.lives;
        let lives_text = format!("Lives: {}", lives_qnty);
        text(&lives_text, 10, 20);
    }
}

fn draw_game_active_screen() {
    draw_sky();
    draw_barriers();
    draw_coin();
    draw_floor();
    draw_player();
    draw_ball();
    draw_hud();
}

fn draw_game_over_screen() {
    unsafe {
        // Clean screen
        *DRAW_COLORS = 1; 
        rect(0, 0, SCREEN_SIZE, 160);
        // Draw Game Over text
        *DRAW_COLORS = 4;
        text("GAME OVER", 40, 60);
        let coins_qnty = PLAYER.score;
        let final_score = format!("Score: {}", coins_qnty);
        text(&final_score, 45, 70);
        text("Press X", 30, 90);
        text("to restart", 30, 100);
    }
}

fn draw_menu_screen() {
    unsafe {
        // Clean screen
        *DRAW_COLORS = 1; 
        rect(0, 0, SCREEN_SIZE, 160);
        // Draw Game Start text
        *DRAW_COLORS = 4;
        text("TITULO DO JOGO", 40, 60);
        text("Press X", 30, 90);
        text("to start", 30, 100);
    }
}

// Update Function ---------------------------------------------------------------------------------------------------------
#[no_mangle]
fn update() {
    // Checks Game State
    unsafe {
        if GAME_MENU {
            // MENU STATE
            check_game_start();
            draw_menu_screen();
        } else if GAME_OVER {
            // GAME OVER STATE
            check_game_start();
            draw_game_over_screen();
        } else {
            // GAME ACTIVE STATE
            game_active_update();
            draw_game_active_screen();
        }
    }

    // Increment Frame Count
    unsafe {
        FRAME_COUNT += 1;
        /*
        TO IMPLEMENT
        // Change Scenario Speed
        if FRAME_COUNT % 1000 == 0 && SCENARIO_SPEED < 2 {
            SCENARIO_SPEED += 1;
        }
        */
    }
}